{% extends "base.html" %}

{% block title %}Rate Photos - {{ year }}/{{ month }} - Home Media AI{% endblock %}

{% block extra_css %}
<style>
    .rating-container {
        display: flex;
        flex-direction: column;
        height: calc(100vh - 60px);
        padding: 1rem;
    }
    .nav-bar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.5rem 1rem;
        background: #1a1a1a;
        border-radius: 8px;
        margin-bottom: 1rem;
    }
    .nav-bar a {
        color: #4a9eff;
        text-decoration: none;
    }
    .nav-bar a:hover {
        text-decoration: underline;
    }
    .progress-info {
        color: #999;
        font-size: 0.9rem;
    }
    .settings-toggle {
        background: #333;
        border: none;
        color: #999;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
    }
    .settings-toggle:hover {
        background: #444;
        color: #e0e0e0;
    }
    .settings-panel {
        display: none;
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    .settings-panel.visible {
        display: block;
    }
    .settings-panel label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: #e0e0e0;
        cursor: pointer;
    }
    .main-view {
        flex: 1;
        display: flex;
        gap: 1rem;
        min-height: 0;
    }
    .image-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: #1a1a1a;
        border-radius: 8px;
        overflow: hidden;
    }
    .content-area {
        flex: 1;
        position: relative;
        min-height: 0;
        overflow: hidden;
    }
    .current-image-container {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #0a0a0a;
    }
    .current-image {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
    }
    .rating-overlay {
        position: absolute;
        top: 1rem;
        left: 1rem;
        background: rgba(0, 0, 0, 0.7);
        padding: 0.5rem 1rem;
        border-radius: 4px;
        font-size: 1.5rem;
        color: #ffd700;
    }
    .info-overlay {
        position: absolute;
        bottom: 1rem;
        left: 1rem;
        background: rgba(0, 0, 0, 0.7);
        padding: 0.5rem 1rem;
        border-radius: 4px;
        font-size: 0.85rem;
        color: #999;
    }
    .burst-view {
        position: absolute;
        inset: 0;
        display: none;
        flex-wrap: wrap;
        gap: 1rem;
        padding: 1rem;
        background: #0a0a0a;
        align-content: center;
        justify-content: center;
        overflow-y: auto;
    }
    .burst-view.active {
        display: flex;
    }
    .burst-item {
        position: relative;
        flex: 0 1 calc(50% - 0.5rem);
        max-width: 600px;
        aspect-ratio: 3/2;
        border: 3px solid #333;
        border-radius: 8px;
        overflow: hidden;
        cursor: pointer;
        transition: all 0.2s;
    }
    .burst-item:hover {
        border-color: #666;
    }
    .burst-item.selected {
        border-color: #4a9eff;
    }
    .burst-item img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        background: #000;
    }
    .burst-item .burst-index {
        position: absolute;
        top: 0.5rem;
        left: 0.5rem;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.9rem;
    }
    .burst-item .burst-rating {
        position: absolute;
        top: 0.5rem;
        right: 0.5rem;
        background: rgba(0, 0, 0, 0.7);
        color: #ffd700;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.9rem;
    }
    .thumbnail-strip {
        display: flex;
        gap: 0.5rem;
        padding: 0.75rem;
        background: #1a1a1a;
        border-top: 1px solid #333;
        overflow-x: auto;
        flex-shrink: 0;
        height: 90px;
    }
    .thumbnail-item {
        flex-shrink: 0;
        width: 100px;
        height: 75px;
        border: 2px solid transparent;
        border-radius: 4px;
        overflow: hidden;
        cursor: pointer;
        opacity: 0.6;
        transition: all 0.2s;
    }
    .thumbnail-item.current {
        border-color: #4a9eff;
        opacity: 1;
    }
    .thumbnail-item:hover {
        opacity: 1;
    }
    .thumbnail-item img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
    .help-panel {
        position: fixed;
        bottom: 1rem;
        right: 1rem;
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 8px;
        padding: 1rem;
        font-size: 0.85rem;
        color: #999;
    }
    .help-panel kbd {
        background: #333;
        padding: 0.2rem 0.5rem;
        border-radius: 3px;
        font-family: monospace;
    }
    .loading-overlay {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.7);
        color: #999;
    }
</style>
{% endblock %}

{% block content %}
<div class="rating-container">
    <div class="nav-bar">
        <a href="/rate">&larr; Back to selection</a>
        <span class="progress-info" id="progress">Loading...</span>
        <button class="settings-toggle" onclick="toggleSettings()">Settings</button>
    </div>

    <div class="settings-panel" id="settings">
        <label>
            <input type="checkbox" id="autoAdvance" onchange="saveSettings()">
            Auto-advance after rating
        </label>
        <label style="margin-left: 2rem;">
            <input type="checkbox" id="unratedOnly" onchange="saveSettings(); loadImages();">
            Only show unrated
        </label>
    </div>

    <div class="main-view">
        <div class="image-panel">
            <div class="content-area">
                <div class="current-image-container" id="imageContainer">
                    <img class="current-image" id="currentImage" src="" alt="">
                    <div class="rating-overlay" id="ratingOverlay"></div>
                    <div class="info-overlay" id="infoOverlay"></div>
                    <div class="loading-overlay" id="loadingOverlay" style="display: none;">Loading...</div>
                </div>
                <div class="burst-view" id="burstView"></div>
            </div>
            <div class="thumbnail-strip" id="thumbnailStrip"></div>
        </div>
    </div>

</div>
{% endblock %}

{% block extra_js %}
const YEAR = {{ year }};
const MONTH = {{ month }};
const BURST_WINDOW = 30;
const CHUNK_SIZE = 500; // Load 500 images at a time

let images = [];
let bursts = [];
let currentIndex = 0;
let inBurstView = false;
let selectedBurstIndex = 0;
let autoAdvance = false;
let unratedOnly = false;
let isLoading = false;
let hasMoreImages = true;
let lastImageId = null;

// Load settings
function loadSettings() {
    autoAdvance = localStorage.getItem('ratingAutoAdvance') === 'true';
    document.getElementById('autoAdvance').checked = autoAdvance;
    unratedOnly = localStorage.getItem('ratingUnratedOnly') === 'true';
    document.getElementById('unratedOnly').checked = unratedOnly;
}

function saveSettings() {
    autoAdvance = document.getElementById('autoAdvance').checked;
    localStorage.setItem('ratingAutoAdvance', autoAdvance);
    unratedOnly = document.getElementById('unratedOnly').checked;
    localStorage.setItem('ratingUnratedOnly', unratedOnly);
}

function toggleSettings() {
    document.getElementById('settings').classList.toggle('visible');
}

// Render stars
function renderStars(rating) {
    if (!rating || rating === 0) return '<span style="color: #666">Not rated</span>';
    return 'â˜…'.repeat(rating) + 'â˜†'.repeat(5 - rating);
}

// Load images for the month (initial load or filter change)
async function loadImages() {
    // Reset pagination state
    images = [];
    bursts = [];
    lastImageId = null;
    hasMoreImages = true;
    currentIndex = 0;

    // Load first chunk
    await loadMoreImages();

    if (images.length > 0) {
        showImage(0);
    } else {
        document.getElementById('imageContainer').innerHTML = '<p style="color: #999">No images found for this month</p>';
    }
}

// Load more images (pagination)
async function loadMoreImages() {
    if (isLoading || !hasMoreImages) {
        return;
    }

    isLoading = true;

    try {
        let url = `/api/rating-queue?year=${YEAR}&month=${MONTH}&burst_window=${BURST_WINDOW}&limit=${CHUNK_SIZE}`;
        if (unratedOnly) {
            url += '&unrated_only=true';
        }
        if (lastImageId) {
            url += `&start_from=${lastImageId}`;
        }

        const response = await fetch(url);
        const data = await response.json();

        if (data.error) {
            alert('Error loading images: ' + data.error);
            return;
        }

        if (data.images.length > 0) {
            // Append new images
            const startIdx = images.length;
            images.push(...data.images);

            // Update last image ID for next pagination
            lastImageId = data.images[data.images.length - 1].id;

            // Check if we got fewer images than requested (means no more)
            if (data.images.length < CHUNK_SIZE) {
                hasMoreImages = false;
            }

            // Merge bursts (recalculate across all images)
            recalculateBursts();

            updateProgress();
            renderThumbnails();
        } else {
            hasMoreImages = false;
        }

    } catch (error) {
        alert('Error loading more images: ' + error.message);
    } finally {
        isLoading = false;
    }
}

// Recalculate bursts across all loaded images
function recalculateBursts() {
    bursts = [];
    if (images.length <= 1) return;

    let current_burst = [images[0]];
    for (let i = 1; i < images.length; i++) {
        const prev_time = images[i-1].created ? new Date(images[i-1].created) : null;
        const curr_time = images[i].created ? new Date(images[i].created) : null;

        if (prev_time && curr_time) {
            const diff = Math.abs((curr_time - prev_time) / 1000);
            if (diff <= BURST_WINDOW) {
                current_burst.push(images[i]);
            } else {
                if (current_burst.length > 1) {
                    bursts.push(current_burst.map(img => img.id));
                }
                current_burst = [images[i]];
            }
        } else {
            if (current_burst.length > 1) {
                bursts.push(current_burst.map(img => img.id));
            }
            current_burst = [images[i]];
        }
    }

    // Don't forget the last burst
    if (current_burst.length > 1) {
        bursts.push(current_burst.map(img => img.id));
    }
}

function updateProgress() {
    const rated = images.filter(img => img.rating && img.rating > 0).length;
    const moreIndicator = hasMoreImages ? '+ (loading more...)' : '';
    document.getElementById('progress').textContent = `${rated} / ${images.length}${moreIndicator} rated`;
}

function renderThumbnails() {
    const strip = document.getElementById('thumbnailStrip');
    strip.innerHTML = images.map((img, idx) => `
        <div class="thumbnail-item ${idx === currentIndex ? 'current' : ''}" onclick="showImage(${idx})">
            <img src="/api/cached-thumbnail/${img.id}" alt="">
        </div>
    `).join('');
}

function showImage(index) {
    if (index < 0 || index >= images.length) return;

    currentIndex = index;
    const img = images[index];

    // Update current image
    document.getElementById('loadingOverlay').style.display = 'flex';
    const imgEl = document.getElementById('currentImage');
    imgEl.onload = () => {
        document.getElementById('loadingOverlay').style.display = 'none';
    };
    imgEl.src = `/api/cached-thumbnail/${img.id}`;

    // Update overlays
    document.getElementById('ratingOverlay').innerHTML = renderStars(img.rating);

    // Show image type badge
    const typeLabel = img.is_original ? 'ðŸ“· Original' : 'âœï¸ Edited';
    document.getElementById('infoOverlay').textContent = `${typeLabel} | ${img.filename} | ${img.created ? new Date(img.created).toLocaleString() : 'Unknown date'}`;

    // Update thumbnail selection
    const thumbs = document.querySelectorAll('.thumbnail-item');
    thumbs.forEach((t, i) => t.classList.toggle('current', i === index));

    // Scroll thumbnail into view
    thumbs[index]?.scrollIntoView({ behavior: 'smooth', inline: 'center' });

    // Check if this image is part of a burst
    const burst = bursts.find(b => b.includes(img.id));
    if (burst && burst.length > 1) {
        showBurstView(burst);
    } else {
        hideBurstView();
    }
}

function showBurstView(burstIds) {
    inBurstView = true;
    selectedBurstIndex = 0;
    const burstView = document.getElementById('burstView');

    const burstImages = burstIds.map(id => images.find(img => img.id === id)).filter(Boolean);

    burstView.innerHTML = burstImages.map((img, idx) => `
        <div class="burst-item ${idx === 0 ? 'selected' : ''}" onclick="selectBurstItem(${idx})" data-id="${img.id}">
            <img src="/api/cached-thumbnail/${img.id}" alt="">
            <span class="burst-index">${idx + 1}</span>
            <span class="burst-rating">${renderStars(img.rating)}</span>
        </div>
    `).join('');

    burstView.classList.add('active');
}

function hideBurstView() {
    inBurstView = false;
    document.getElementById('burstView').classList.remove('active');
}

function selectBurstItem(index) {
    selectedBurstIndex = index;
    const items = document.querySelectorAll('.burst-item');
    items.forEach((item, i) => item.classList.toggle('selected', i === index));
}

// Rate image
async function rateImage(imageId, rating) {
    try {
        const response = await fetch(`/api/rating/${imageId}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ rating })
        });

        const data = await response.json();
        if (data.error) {
            console.error('Rating error:', data.error);
            return false;
        }

        // Update local data
        const img = images.find(i => i.id === imageId);
        if (img) img.rating = rating;

        return true;
    } catch (error) {
        console.error('Rating error:', error);
        return false;
    }
}

// Handle rating in normal view
async function handleRating(rating) {
    if (inBurstView) {
        await handleBurstRating(rating);
    } else {
        const img = images[currentIndex];
        const success = await rateImage(img.id, rating);

        if (success) {
            document.getElementById('ratingOverlay').innerHTML = renderStars(rating);
            updateProgress();

            if (autoAdvance) {
                setTimeout(() => navigate(1), 200);
            }
        }
    }
}

// Handle rating in burst view
async function handleBurstRating(rating) {
    const burstItems = document.querySelectorAll('.burst-item');
    const selectedId = parseInt(burstItems[selectedBurstIndex].dataset.id);

    // Rate selected image
    await rateImage(selectedId, rating);

    // Update display
    const selectedRatingEl = burstItems[selectedBurstIndex].querySelector('.burst-rating');
    selectedRatingEl.innerHTML = renderStars(rating);

    updateProgress();
}

// Navigate with arrow keys - jump between burst groups
function navigate(direction) {
    // Auto-rate unrated images in current burst as 1 before leaving
    if (inBurstView) {
        const burstItems = document.querySelectorAll('.burst-item');
        burstItems.forEach(item => {
            const id = parseInt(item.dataset.id);
            const img = images.find(i => i.id === id);
            if (img && (!img.rating || img.rating === 0)) {
                rateImage(id, 1);
                img.rating = 1;
            }
        });
        updateProgress();
    }

    // Auto-load more images if we're getting close to the end
    if (direction > 0 && currentIndex > images.length - 50 && hasMoreImages && !isLoading) {
        loadMoreImages();
    }

    // Find the next burst group or single image
    const newIndex = findNextGroup(currentIndex, direction);
    if (newIndex !== null) {
        showImage(newIndex);
    }
}

// Find the next burst group or single image
function findNextGroup(fromIndex, direction) {
    const currentImg = images[fromIndex];
    const currentBurst = bursts.find(b => b.includes(currentImg.id));

    if (direction > 0) {
        // Moving forward
        if (currentBurst) {
            // Skip to after the current burst
            const lastBurstId = currentBurst[currentBurst.length - 1];
            const lastBurstIndex = images.findIndex(img => img.id === lastBurstId);

            // Find next image that's not in the same burst
            for (let i = lastBurstIndex + 1; i < images.length; i++) {
                return i;
            }
        } else {
            // Currently on a single image, move to next
            if (fromIndex + 1 < images.length) {
                return fromIndex + 1;
            }
        }
    } else {
        // Moving backward
        if (currentBurst) {
            // Skip to before the current burst
            const firstBurstId = currentBurst[0];
            const firstBurstIndex = images.findIndex(img => img.id === firstBurstId);

            // Find previous image
            if (firstBurstIndex > 0) {
                return firstBurstIndex - 1;
            }
        } else {
            // Currently on a single image, move to previous
            if (fromIndex > 0) {
                return fromIndex - 1;
            }
        }
    }

    return null; // No more groups in that direction
}

// Keyboard handler
document.addEventListener('keydown', (e) => {
    // Number keys 0-5 for rating
    if (e.key >= '0' && e.key <= '5') {
        e.preventDefault();
        handleRating(parseInt(e.key));
        return;
    }

    switch (e.key) {
        case 'ArrowLeft':
            e.preventDefault();
            navigate(-1);
            break;
        case 'ArrowRight':
            e.preventDefault();
            navigate(1);
            break;
        case 'Escape':
            if (inBurstView) {
                e.preventDefault();
                hideBurstView();
            }
            break;
    }
});

// Initialize
loadSettings();
loadImages();
{% endblock %}
